# 仍可能导致密文被解密的风险点

当前项目已采用：Ratchet 单向推进、不存 seed、统一时间源、仅保留当前/上一时间槽。**过期（超过约 2 分钟）的密文在数学上不可再解**，前提是下面这些点没有被人利用或出错。

---

## 保证：助记词+口令也无法解开过期密文

**在时间源未被篡改的前提下**，可以保证：

- **即使攻击者拿到助记词和口令**，只要某条密文的**加密时间已经过期**（超过当前/上一时间槽对应的约 1～2 分钟），**就无法再解密该密文**。
- 原因：`initRatchet(mnemonic, passphrase)` 只会用**当前**时间槽 T_now 推导 (T_now-1, T_now) 两个槽状态，不存 seed，也从不对过去的 T_old 计算 `kdfSlotFromSeed(seed, T_old)`。因此拿到助记词后重新 init，只能得到“现在”的槽，得不到加密时刻的槽，过期密文对应的密钥材料已不可恢复。

**唯一例外**：若攻击者能篡改时间源或本机时间，使“当前时间”被伪造成过去（加密时刻），则可能重新推导出当时的槽状态并解密。参见下文「统一时间源被篡改」。

---

## 1. 统一时间源被篡改（可重新“打开”过期密文）

**现象**：若攻击者能控制或篡改“当前时间”的来源，可以让本机认为“当前时间”是过去的某一刻，从而重新推导出**过去**时间槽的状态，进而解密当时产生的密文。

**具体**：

- `syncTime` 依赖外部时间 API（如 worldtimeapi.org）。若：
  - 时间 API 被攻破或恶意运营，或
  - 请求被 MITM 并篡改响应（例如返回 10 分钟前的 `unixtime`），
- 则 `getSyncedTimeSlotAsync()` 会得到“过去的”时间槽 T_old。
- 下次 `initRatchet(mnemonic, passphrase)` 时，会用 T_old 推导出 (T_old-1, T_old) 的槽状态。
- 于是本机就重新拥有了“过去那一分钟”的密钥材料，**本应已过期的密文又可被解密**。

**缓解**：

- 使用可信、HTTPS 且尽量可验证的时间源；生产环境可考虑自建或多家时间源交叉校验。
- 若需更强保证，可限制“允许的时间偏移”（例如拒绝与本地时间差过大的服务器时间），减少滥用“回溯时间”的能力。

---

## 2. 助记词常驻内存（只影响“近期”密文）

**现象**：助记词存在于 React 状态 `config.mnemonic` 中，只要页面未卸载就会一直留在内存里。

**影响**：

- 能读本机内存的人（恶意扩展、调试、内存转储等）可以拿到助记词。
- 拿到后只能再调用 `initRatchet(mnemonic, passphrase)`，得到**当前**时间槽 (T-1, T)，因此只能解密**最近约 2 分钟内**的密文。
- **不会**因此恢复更早时间槽的密钥（因为不存 seed、不存历史槽状态），所以**不会**重新打开已过期的密文。

**结论**：这是“近期密文可被同机攻击者解密”的问题，不是“过期密文被重新解开”的问题。若需降低风险，可在 `initRatchet` 成功后从 UI 上清空或不再展示助记词（需权衡体验与恢复方式）。

---

## 3. 默认助记词未更换（演示/测试用风险）

**现象**：`constants.ts` 中存在 `DEFAULT_MNEMONIC`，若用户不修改，加密会用该公开助记词。

**影响**：

- 任何人知道该助记词后，可在**当前时间**下 `initRatchet(defaultMnemonic)`，得到当前 (T-1, T)，从而解密**最近 2 分钟**内用默认助记词加密的密文。
- 若再结合**时间源被篡改**（上文 1），攻击者还可以通过“伪造过去时间”得到过去的 (T_old-1, T_old)，从而解密**更早**的、本应已过期的密文。

**缓解**：

- 仅作演示时使用默认助记词；生产或真实数据必须强制用户设置并不可使用默认值。
- 在 UI/文档中明确提示：默认助记词仅用于测试，不可用于真实敏感内容。

---

## 4. Ratchet 状态未持久化（设计如此，无额外“可解密”风险）

**现象**：`ratchetState` 仅存在于内存，刷新或关闭页面后丢失。

**影响**：

- 不持久化 → 不把槽状态或 seed 写入磁盘/同步，**不会**增加“过期密文被解密”的可能。
- 唯一影响是：刷新后需要重新 `initRatchet(mnemonic, passphrase)`，且**只能**再得到“当前”的 (T-1, T)，历史密文依然不可解。

**结论**：当前设计有利于“过期即不可解”，无需为“防止解密”而改动；若将来要做跨会话解密，需单独设计密钥/状态持久化与安全存储。

---

## 5. 解密重试范围（msgIndex 0..10）

**现象**：解密时对 msgIndex 只尝试 0～10。

**影响**：

- 若某条消息加密时使用的 msgIndex > 10，合法用户也会解密失败；**不会**多解出不该解开的密文。
- 若将来单时间槽内消息数可能超过 10，需要增大 `MAX_MSG_INDEX_RETRY` 或改为按消息记录 msgIndex。

**结论**：这是可用性问题，不是“密文被不该解密的人解密”的问题。

---

## 小结（按“能否解开密文”分类）

| 风险 | 是否会导致“本不可解的密文被解开” | 说明 |
|------|----------------------------------|------|
| 时间源被篡改 | ✅ 会 | 可回溯时间槽，重新推导过去槽状态，解密过期密文。 |
| 助记词在内存 | ❌ 不会 | 只能得到当前 (T-1,T)，仅影响近期约 2 分钟。 |
| 默认助记词 | ✅ 会（在默认+时间被篡改时） | 已知助记词 + 伪造过去时间 → 可解过期密文。 |
| Ratchet 不持久化 | ❌ 不会 | 不增加解密能力。 |
| msgIndex 0..10 | ❌ 不会 | 只可能少解，不会多解。 |

**整体**：在**时间源可信、未使用默认助记词、助记词未泄露**的前提下，过期密文不会被解密。最大剩余风险是**时间 API 被控制或篡改**，导致“回溯时间”并重新打开过期时间槽。
